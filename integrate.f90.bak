SUBROUTINE trapzd(func,a,b,s,n)
USE nrtype; USE nrutil, ONLY: arth
IMPLICIT NONE
REAL(SP),INTENT(IN):: a,b
REAL(SP),INTENT(INOUT):: s
INTEGER(I4B),INTENT(IN):: n
INTERFACE
	FUNCTION func(x)
	USE nrtype
	REAL(SP),DIMENSION(:),INTENT(IN):: x
	REAL(SP),DIMENSION(size(x)):: func
	END FUNCTION func
END INTERFACE
! This routine computes the nth stage of refinement of an extended trapeziodal
! rule. func is input as the name of the function to be integrated between
! limits a and b, also input. When called with n=1, the routine returns as s 
! the crudest estimate of int_a^b f(x)dx. Subsequent calls with n=2,3,.. (in
! that sequential order) will improve the accuracy of s by adding 2^(n-2) additional
! interior points, a should not be modified between sequential calls.
REAL(SP):: del,fsum
INTEGER(I4B):: it
if(n==1) then
	s=0.5_sp*(b-a)*sum(func((/ a,b /)))
else
	it=2**(n-2)
	del=(b-a)/it	! This is the spacing of the points to be added.
	fsum=sum(func(arth(a+0.5_sp*del,del,it)))
	s=0.5_sp*(s+del*fsum)	! This replaces s by its refined value.
end if
END SUBROUTINE trapzd


FUNCTION qtrap(func,a,b)
USE nrtype; USE nrutil, ONLY: nrerror
IMPLICIT NONE
REAL(SP),INTENT(IN):: a,b
REAL(SP):: qtrap
INTERFACE
	FUNCTION func(x)
	USE nrtype
	REAL(SP),DIMENSION(:),INTENT(IN):: x
	REAL(SP),DIMENSION(size(x)):: func
	END FUNCTION func
END INTERFACE
INTEGER(I4B),PARAMETER:: JMAX=20
REAL(SP),PARAMETER:: EPS=1.0e-6_sp, UNLIKELY=-1.0e30_sp
! Returns the integral of the function func from a to b. The
! parameter EPS should be set to the desired fractional accuracy
! and JMAX so that 2 to the power JMAX-1 is the maximum allowed
! number of steps. Integration is performed by the trapezoidal rule.
REAL(SP):: olds
INTEGER(I4B):: j	! Any number that is unlikely to be the average
olds=UNLIKELY		! of the function at its endpoints will do here.
do j=1,JMAX
	call trapzd(func,a,b,qtrap,j)
	if (j>5) then	! Avoid spurious early convergence.
		if (abs(qtrap-olds) < EPS*abs(olds) .or. &
			(qtrap == 0.0 .and. olds == 0.0)) RETURN
	end if
	olds=qtrap
end do
call nrerror('qtrap: too many steps')
END FUNCTION qtrap


FUNCTION qsimp(func,a,b)
USE nrtype; USE nrutil, ONLY: nrerror
IMPLICIT NONE
REAL(SP),INTENT(IN):: a,b
REAL(SP):: qsimp
INTERFACE
	FUNCTION func(x)
	USE nrtype
	REAL(SP),DIMENSION(:),INTENT(IN):: x
	REAL(SP),DIMENSION(size(x)):: func
	END FUNCTION func
END INTERFACE
INTEGER(I4B),PARAMETER:: JMAX=20
REAL(SP),PARAMETER:: EPS=1.0e-6_sp, UNLIKELY=-1.0e30_sp
! Returns the integral of the function func from a to b. The
! parameter EPS should be set to the desired fractional accuracy
! and JMAX so that 2 to the power JMAX-1 is the maximum allowed
! number of steps. Integration is performed by Simpson's rule.
INTEGER(I4B):: j
REAL(SP):: os,ost,st
ost=UNLIKELY
os=UNLIKELY
do j=1,JMAX
	call trapzd(func,a,b,st,j)
	qsimp=(4.0_sp*st-ost)/3.0_sp	! Compare equation (4.2.4)
	if (j>5) then					! Avoid spurious early convergence
		if (abs(qsimp-os) < EPS*abs(os) .or. &
			(qsimp == 0.0 .and. os == 0.0)) RETURN
	end if
	os=qsimp
	ost=os
end do
call nrerror('qsimp: too many steps')
END FUNCTION qsimp


SUBROUTINE midpnt(func,a,b,s,n)
USE nrtype; USE nrutil, ONLY: arth
IMPLICIT NONE
REAL(SP),INTENT(IN):: a,b
REAL(SP),INTENT(INOUT):: s
INTEGER(I4B),INTENT(IN):: n
INTERFACE
	FUNCTION func(x)
	USE nrtype
	REAL(SP),DIMENSION(:),INTENT(IN):: x
	REAL(SP),DIMENSION(size(x)):: func
	END FUNCTION func
END INTERFACE
! This routine computes the nth stage of refinement of an
! extended midpoint rule. func is input as the name of the 
! function to be integrated between limits a and b, also 
! input. When called with n=1, the routine as s the crudest
! estimate of int^b_a f(x)dx. Subsequent calls with n=2,3,..
! (in that sequential order) will improve the accuracy of s
! by adding (2/3)x3^(n-1) additional interior points. s should
! not be modified between sequential calls.
REAL(SP):: del
INTEGER(I4B):: it
REAL(SP),DIMENSION(2*3**(n-2)):: x
if (n == 1) then
	s=(b-a)*sum(func( (/0.5_sp*(a+b)/) ))
else
	it=3**(n-2)
	del=(b-a)/(3.0_sp*it)	! The added points alternate in spacing between
	x(1:2*it-1:2)=arth(a+0.5_sp*del,3.0_sp*del,it)	! del and 2*del.
	x(2:2*it:2)=x(1:2*it-1:2)+2.0_sp*del
	s=s/3.0_sp+del*sum(func(x))	! The new sum is combined with the old integral
end if							! to give a refined integral.
END SUBROUTINE midpnt
